# v2.1 动态音频会话静音功能 - 实施计划

## 📋 版本信息

**版本**: v2.1.0  
**目标**: 提升音频纯净度从 60% → 90%  
**开发时间**: 预计 1-2 天  
**发布日期**: 2025-10-14  

---

## 🎯 核心目标

### 问题描述

**v2.0.0 的限制**:
```
场景: 用户使用Chrome看YouTube + QQ音乐同时播放

当前效果:
┌────────────────────────────────┐
│ Chrome (YouTube) ♪♪♪          │ ← 目标音频
│ QQ音乐 (背景音乐) ♫♫♫         │ ← 噪音
├────────────────────────────────┤
│ 捕获结果: YouTube + QQ音乐混合 │ ← 不纯净 (60%)
└────────────────────────────────┘
```

**v2.1.0 目标**:
```
场景: 同上

v2.1效果:
┌────────────────────────────────┐
│ Chrome (YouTube) ♪♪♪          │ ← 捕获
│ QQ音乐 (背景音乐) 🔇 自动静音  │ ← 被屏蔽
├────────────────────────────────┤
│ 捕获结果: 只有YouTube         │ ← 纯净 (90%)
└────────────────────────────────┘
```

---

## 🏗️ 技术架构

### 核心实现思路

```cpp
// v2.0: 简单检测
if (IsTargetProcessPlayingAudio(targetPid)) {
    CaptureSystemAudio();  // 捕获所有（包括噪音）
} else {
    OutputSilence();
}

// v2.1: 动态静音
EnumerateAllAudioSessions();
foreach (session in sessions) {
    if (session.processId == targetPid) {
        // 保持目标进程不静音
        session.SetMute(false);
    } else if (!IsInAllowList(session.processId)) {
        // 静音其他进程
        session.SetMute(true);
    }
}
CaptureSystemAudio();  // 现在只有目标进程音频
```

### API设计

```javascript
// JavaScript API
const processor = new AudioProcessor();

// 方式1: 初始化时配置
processor.initializeWithProcessFilter(targetPid, {
    muteOtherProcesses: true,    // 自动静音其他进程
    allowList: [1234, 5678],     // 白名单（不静音）
    blockList: [9999]            // 黑名单（强制静音）
});

// 方式2: 运行时配置
processor.setMuteOtherProcesses(true);
processor.setAllowList([1234, 5678]);
processor.setBlockList([9999]);

// 查询当前状态
const isMuting = processor.isMutingOtherProcesses();
const allowList = processor.getAllowList();
```

---

## 📝 实施步骤

### Step 1: 扩展 AudioSessionManager 类 ✓

**文件**: `src/wasapi/audio_session_manager.h`

```cpp
class AudioSessionManager {
public:
    // 新增方法
    bool MuteAllExcept(DWORD targetPid, 
                       const std::vector<DWORD>& allowList);
    bool UnmuteAll();
    bool SaveMuteStates();    // 保存原始静音状态
    bool RestoreMuteStates(); // 恢复原始静音状态
    
private:
    // 新增成员
    std::map<DWORD, bool> originalMuteStates_;  // PID -> 原始静音状态
    bool isManagingMuteStates_ = false;
};
```

**文件**: `src/wasapi/audio_session_manager.cpp`

```cpp
bool AudioSessionManager::MuteAllExcept(
    DWORD targetPid,
    const std::vector<DWORD>& allowList) {
    
    if (!sessionManager_) return false;
    
    // 1. 保存原始状态
    if (!isManagingMuteStates_) {
        SaveMuteStates();
        isManagingMuteStates_ = true;
    }
    
    // 2. 枚举所有会话
    auto sessions = EnumerateSessions();
    
    // 3. 应用静音规则
    for (const auto& session : sessions) {
        bool shouldMute = true;
        
        // 目标进程不静音
        if (session.processId == targetPid) {
            shouldMute = false;
        }
        // 白名单不静音
        else if (std::find(allowList.begin(), allowList.end(), 
                          session.processId) != allowList.end()) {
            shouldMute = false;
        }
        
        // 应用静音
        SetProcessMute(session.processId, shouldMute);
    }
    
    return true;
}

bool AudioSessionManager::UnmuteAll() {
    return RestoreMuteStates();
}
```

**预计时间**: 2-3小时

---

### Step 2: AudioClient 集成动态静音 ✓

**文件**: `src/wasapi/audio_client.h`

```cpp
class AudioClient {
public:
    // 扩展初始化方法
    struct ProcessFilterOptions {
        bool muteOtherProcesses = false;
        std::vector<DWORD> allowList;
        std::vector<DWORD> blockList;
    };
    
    bool InitializeWithProcessFilter(
        DWORD processId, 
        const ProcessFilterOptions& options = {});
    
    // 运行时配置
    void SetMuteOtherProcesses(bool enable);
    void SetAllowList(const std::vector<DWORD>& pids);
    void SetBlockList(const std::vector<DWORD>& pids);
    
    bool IsMutingOtherProcesses() const;
    
private:
    ProcessFilterOptions filterOptions_;
    void ApplyMuteControl();  // 应用静音控制
};
```

**文件**: `src/wasapi/audio_client.cpp`

```cpp
bool AudioClient::InitializeWithProcessFilter(
    DWORD processId,
    const ProcessFilterOptions& options) {
    
    // 1. 标准初始化
    if (!Initialize(params)) return false;
    
    // 2. 初始化会话管理器
    if (!sessionManager_->Initialize(device_.Get())) return false;
    
    // 3. 保存配置
    filterProcessId_ = processId;
    filterOptions_ = options;
    
    // 4. 立即应用静音控制
    if (filterOptions_.muteOtherProcesses) {
        ApplyMuteControl();
    }
    
    return true;
}

void AudioClient::ApplyMuteControl() {
    if (!filterOptions_.muteOtherProcesses) return;
    
    // 合并白名单和允许列表
    std::vector<DWORD> allowList = filterOptions_.allowList;
    
    // 应用静音
    sessionManager_->MuteAllExcept(filterProcessId_, allowList);
}

void AudioClient::SetMuteOtherProcesses(bool enable) {
    filterOptions_.muteOtherProcesses = enable;
    
    if (enable) {
        ApplyMuteControl();
    } else {
        sessionManager_->UnmuteAll();
    }
}
```

**预计时间**: 2-3小时

---

### Step 3: 更新 JavaScript 绑定 ✓

**文件**: `src/napi/audio_processor.cpp`

```cpp
// 新增方法绑定
Napi::Value AudioProcessor::InitializeWithProcessFilter(
    const Napi::CallbackInfo& info) {
    
    Napi::Env env = info.Env();
    
    // 参数1: processId (必需)
    if (info.Length() < 1) {
        throw Napi::TypeError::New(env, "processId required");
    }
    DWORD processId = info[0].As<Napi::Number>().Uint32Value();
    
    // 参数2: options (可选)
    AudioClient::ProcessFilterOptions options;
    if (info.Length() >= 2 && info[1].IsObject()) {
        Napi::Object opts = info[1].As<Napi::Object>();
        
        // muteOtherProcesses
        if (opts.Has("muteOtherProcesses")) {
            options.muteOtherProcesses = 
                opts.Get("muteOtherProcesses").As<Napi::Boolean>();
        }
        
        // allowList
        if (opts.Has("allowList") && 
            opts.Get("allowList").IsArray()) {
            Napi::Array arr = opts.Get("allowList").As<Napi::Array>();
            for (uint32_t i = 0; i < arr.Length(); i++) {
                options.allowList.push_back(
                    arr.Get(i).As<Napi::Number>().Uint32Value());
            }
        }
        
        // blockList
        if (opts.Has("blockList") && 
            opts.Get("blockList").IsArray()) {
            Napi::Array arr = opts.Get("blockList").As<Napi::Array>();
            for (uint32_t i = 0; i < arr.Length(); i++) {
                options.blockList.push_back(
                    arr.Get(i).As<Napi::Number>().Uint32Value());
            }
        }
    }
    
    // 调用C++方法
    bool success = audioClient_->InitializeWithProcessFilter(
        processId, options);
    
    return Napi::Boolean::New(env, success);
}

// 运行时配置方法
Napi::Value AudioProcessor::SetMuteOtherProcesses(
    const Napi::CallbackInfo& info) {
    
    bool enable = info[0].As<Napi::Boolean>();
    audioClient_->SetMuteOtherProcesses(enable);
    return info.Env().Undefined();
}

// 注册方法
Napi::Object Init(Napi::Env env, Napi::Object exports) {
    // ... 现有代码 ...
    
    // 添加新方法
    InstanceMethod("setMuteOtherProcesses", 
                   &AudioProcessor::SetMuteOtherProcesses),
    InstanceMethod("setAllowList", 
                   &AudioProcessor::SetAllowList),
    InstanceMethod("setBlockList", 
                   &AudioProcessor::SetBlockList),
    InstanceMethod("isMutingOtherProcesses", 
                   &AudioProcessor::IsMutingOtherProcesses),
}
```

**预计时间**: 2小时

---

### Step 4: 编写测试用例 ✓

**文件**: `test-v2.1-mute-control.js`

```javascript
const { AudioProcessor } = require('./build/Release/audio_addon.node');

console.log('🧪 v2.1 动态静音控制测试\n');

// 1. 查找目标进程和干扰进程
function findProcessByName(sessions, name) {
    return sessions.find(s => 
        s.displayName.toLowerCase().includes(name.toLowerCase()));
}

async function testMuteControl() {
    const processor = new AudioProcessor();
    
    try {
        // 枚举会话
        const sessions = processor.enumerateAudioSessions();
        console.log('📋 当前音频会话:');
        sessions.forEach(s => {
            console.log(`  - ${s.displayName} (PID: ${s.processId})`);
        });
        
        // 查找Chrome和QQ音乐
        const chrome = findProcessByName(sessions, 'chrome');
        const qqmusic = findProcessByName(sessions, 'qqmusic');
        
        if (!chrome) {
            console.log('⚠️ 未找到Chrome，请打开YouTube视频');
            return;
        }
        
        console.log(`\n✅ 目标进程: ${chrome.displayName} (${chrome.processId})`);
        if (qqmusic) {
            console.log(`✅ 干扰进程: ${qqmusic.displayName} (${qqmusic.processId})`);
        }
        
        // 测试1: 不启用静音控制（v2.0行为）
        console.log('\n\n📊 测试1: v2.0模式（不静音其他进程）');
        console.log('   请在Chrome播放视频，同时播放QQ音乐');
        console.log('   预期: 捕获到混合音频\n');
        
        processor.initializeWithProcessFilter(chrome.processId);
        processor.start();
        
        await sleep(5000);
        
        processor.stop();
        console.log('✅ 测试1完成');
        
        // 测试2: 启用静音控制（v2.1行为）
        console.log('\n\n📊 测试2: v2.1模式（静音其他进程）');
        console.log('   保持Chrome和QQ音乐播放');
        console.log('   预期: 只捕获Chrome音频，QQ被静音\n');
        
        processor.initializeWithProcessFilter(chrome.processId, {
            muteOtherProcesses: true
        });
        processor.start();
        
        await sleep(5000);
        
        processor.stop();
        console.log('✅ 测试2完成');
        
        // 测试3: 白名单功能
        if (qqmusic) {
            console.log('\n\n📊 测试3: 白名单功能');
            console.log('   将QQ音乐加入白名单');
            console.log('   预期: Chrome和QQ音乐都不被静音\n');
            
            processor.initializeWithProcessFilter(chrome.processId, {
                muteOtherProcesses: true,
                allowList: [qqmusic.processId]
            });
            processor.start();
            
            await sleep(5000);
            
            processor.stop();
            console.log('✅ 测试3完成');
        }
        
        // 测试4: 运行时切换
        console.log('\n\n📊 测试4: 运行时动态切换');
        
        processor.initializeWithProcessFilter(chrome.processId);
        processor.start();
        
        console.log('   初始状态: 不静音 (5秒)');
        await sleep(5000);
        
        console.log('   切换: 启用静音 (5秒)');
        processor.setMuteOtherProcesses(true);
        await sleep(5000);
        
        console.log('   切换: 禁用静音 (5秒)');
        processor.setMuteOtherProcesses(false);
        await sleep(5000);
        
        processor.stop();
        console.log('✅ 测试4完成');
        
        console.log('\n\n🎉 所有测试完成！');
        
        // 验证状态
        console.log('\n📈 功能验证:');
        console.log(`  静音控制状态: ${processor.isMutingOtherProcesses()}`);
        
    } catch (error) {
        console.error('❌ 测试失败:', error.message);
    }
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// 运行测试
testMuteControl().catch(console.error);
```

**预计时间**: 1小时

---

### Step 5: 更新文档 ✓

**文件**: `V2.1_RELEASE_NOTES.md`

完整的v2.1发布说明，包括：
- 新功能介绍
- API变更说明
- 使用示例
- 升级指南

**文件**: `README.md` (更新v2.1示例)

**文件**: `V2_PROCESS_FILTER_GUIDE.md` (添加v2.1章节)

**预计时间**: 1-2小时

---

## 📊 实施时间表

| 任务 | 预计时间 | 状态 |
|------|---------|------|
| Step 1: AudioSessionManager扩展 | 2-3小时 | ⏳ 待开始 |
| Step 2: AudioClient集成 | 2-3小时 | ⏳ 待开始 |
| Step 3: JavaScript绑定 | 2小时 | ⏳ 待开始 |
| Step 4: 测试用例 | 1小时 | ⏳ 待开始 |
| Step 5: 文档更新 | 1-2小时 | ⏳ 待开始 |
| **总计** | **8-11小时** | **1-2天** |

---

## 🎯 成功标准

### 功能性指标

- ✅ 能够自动静音非目标进程
- ✅ 白名单进程不被静音
- ✅ 黑名单进程强制静音
- ✅ 运行时可动态切换
- ✅ 停止捕获时恢复原始静音状态

### 性能指标

- ✅ 静音操作延迟 < 100ms
- ✅ 不影响音频捕获性能
- ✅ 内存占用增加 < 1MB

### 质量指标

- ✅ 音频纯净度提升到 90%
- ✅ 多任务场景噪音减少 > 80%
- ✅ 所有测试用例通过
- ✅ 向后兼容v2.0 API

---

## 🔧 技术要点

### 1. 状态管理

```cpp
// 保存原始状态，确保恢复时不影响用户配置
originalMuteStates_[processId] = currentMuteState;

// 停止时恢复
for (auto& [pid, state] : originalMuteStates_) {
    SetProcessMute(pid, state);
}
```

### 2. 实时更新

```cpp
// 在捕获循环中周期性检查新会话
void AudioClient::CaptureLoop() {
    while (isCapturing_) {
        // 每秒检查一次新会话
        if (++frameCount % sampleRate == 0) {
            ApplyMuteControl();  // 重新应用静音规则
        }
        
        // 捕获音频...
    }
}
```

### 3. 错误处理

```cpp
// 处理会话消失的情况
if (session->GetState() == AudioSessionStateExpired) {
    originalMuteStates_.erase(processId);
    continue;
}
```

---

## 🚀 开始实施

现在开始按步骤实施v2.1功能：

**当前任务**: Step 1 - 扩展 AudioSessionManager 类

**文件**: `src/wasapi/audio_session_manager.h`

准备开始编码...
